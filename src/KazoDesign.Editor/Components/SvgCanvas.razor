@using KazoDesign.Editor.Models
@using KazoDesign.Editor.Services
@inject DesignService DesignService
@inject IJSRuntime JS

<div class="canvas-container" @ref="_containerRef">
    <svg @ref="_svgRef"
         class="design-canvas"
         viewBox="@ViewBox"
         @onmousedown="OnMouseDown"
         @onmousemove="OnMouseMove"
         @onmouseup="OnMouseUp"
         @onmouseleave="OnMouseUp"
         @ondblclick="OnDoubleClick"
         @onwheel="OnWheel">
        
        <!-- Background -->
        <rect x="0" y="0" 
              width="@Document.CanvasWidth.ToString(System.Globalization.CultureInfo.InvariantCulture)" 
              height="@Document.CanvasHeight.ToString(System.Globalization.CultureInfo.InvariantCulture)" 
              fill="@Document.BackgroundColor" />
        
        <!-- Grid Pattern -->
        <defs>
            <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
                <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#333" stroke-width="0.5"/>
            </pattern>
        </defs>
        <rect x="0" y="0" 
              width="@Document.CanvasWidth.ToString(System.Globalization.CultureInfo.InvariantCulture)" 
              height="@Document.CanvasHeight.ToString(System.Globalization.CultureInfo.InvariantCulture)" 
              fill="url(#grid)" />
        
        <!-- Render all elements in current view context -->
        @foreach (var element in DesignService.GetCurrentViewElements())
        {
            @switch (element)
            {
                case KRectangle rect:
                    <KRectangleRenderer Shape="@rect" />
                    break;
                case KCircle circle:
                    <KCircleRenderer Shape="@circle" />
                    break;
                case KLine line:
                    <KLineRenderer Shape="@line" />
                    break;
                case KText text:
                    <KTextRenderer Shape="@text" />
                    break;
                case KImage image:
                    <KImageRenderer Shape="@image" />
                    break;
            }
        }
        
        <!-- Selection handles for selected element -->
        @if (SelectedElement != null)
        {
            <SelectionHandles Element="@SelectedElement" OnResizeStart="OnResizeStart" />
        }
    </svg>
</div>

@code {
    private ElementReference _svgRef;
    private ElementReference _containerRef;
    
    private bool _isDragging;
    private bool _isResizing;
    private bool _isDrawing;
    private DesignElement? _drawingElement;
    private SelectionHandles.ResizeHandle _currentResizeHandle;
    private double _dragStartX;
    private double _dragStartY;
    private double _elementStartX;
    private double _elementStartY;
    private double _elementStartWidth;
    private double _elementStartHeight;
    private double _elementStartRadius;
    private double _lineEndOffsetX;  // Offset from line start to end point
    private double _lineEndOffsetY;
    
    private double _zoom = 1.0;
    private double _panX = 0;
    private double _panY = 0;
    
    public DesignDocument Document => DesignService.Document;
    public DesignElement? SelectedElement => DesignService.SelectedElement;
    
    private string ViewBox => $"{_panX} {_panY} {Document.CanvasWidth / _zoom} {Document.CanvasHeight / _zoom}";
    
    protected override void OnInitialized()
    {
        DesignService.OnChange += StateHasChanged;
    }
    
    public void Dispose()
    {
        DesignService.OnChange -= StateHasChanged;
    }
    
    private async Task<(double x, double y)> GetSvgPoint(MouseEventArgs e)
    {
        try
        {
            var result = await JS.InvokeAsync<double[]>("kazoDesign.getSvgPoint", _svgRef, e.ClientX, e.ClientY);
            return (result[0], result[1]);
        }
        catch
        {
            return (e.ClientX, e.ClientY);
        }
    }
    
    private async Task OnMouseDown(MouseEventArgs e)
    {
        var (x, y) = await GetSvgPoint(e);
        
        // If we're in a drawing mode (not Select), start drawing
        if (DesignService.CurrentTool != DrawingTool.Select)
        {
            StartDrawing(x, y);
            return;
        }
        
        // Find element under cursor in current view context (reverse order for z-index)
        DesignElement? clickedElement = null;
        var currentViewElements = DesignService.GetCurrentViewElements().ToList();
        for (int i = currentViewElements.Count - 1; i >= 0; i--)
        {
            if (currentViewElements[i].ContainsPoint(x, y))
            {
                clickedElement = currentViewElements[i];
                break;
            }
        }
        
        DesignService.SelectElement(clickedElement);
        
        if (clickedElement != null)
        {
            _isDragging = true;
            _dragStartX = x;
            _dragStartY = y;
            _elementStartX = clickedElement.X;
            _elementStartY = clickedElement.Y;
            
            // Store line end offset for proper line movement
            if (clickedElement is KLine line)
            {
                _lineEndOffsetX = line.X2 - line.X;
                _lineEndOffsetY = line.Y2 - line.Y;
            }
        }
    }
    
    private void StartDrawing(double x, double y)
    {
        _isDrawing = true;
        _dragStartX = x;
        _dragStartY = y;
        
        switch (DesignService.CurrentTool)
        {
            case DrawingTool.Rectangle:
                _drawingElement = new KRectangle
                {
                    X = x,
                    Y = y,
                    Width = 0,
                    Height = 0,
                    Description = "New rectangle"
                };
                Document.Elements.Add(_drawingElement);
                break;
                
            case DrawingTool.Circle:
                _drawingElement = new KCircle
                {
                    X = x,
                    Y = y,
                    Radius = 0,
                    Description = "New circle"
                };
                Document.Elements.Add(_drawingElement);
                break;
                
            case DrawingTool.Line:
                _drawingElement = new KLine
                {
                    X = x,
                    Y = y,
                    X2 = x,
                    Y2 = y,
                    Description = "New line"
                };
                Document.Elements.Add(_drawingElement);
                break;
                
            case DrawingTool.Text:
                // Text is added on click, not drag
                var text = new KText
                {
                    X = x,
                    Y = y,
                    Content = "New Text",
                    FontSize = 18,
                    Description = "New text element"
                };
                DesignService.AddElement(text);
                DesignService.CurrentTool = DrawingTool.Select;
                _isDrawing = false;
                return;
        }
        
        DesignService.NotifyStateChanged();
    }
    
    private async Task OnDoubleClick(MouseEventArgs e)
    {
        var (x, y) = await GetSvgPoint(e);
        
        // Find element under cursor in current view context (reverse order for z-index)
        DesignElement? clickedElement = null;
        var currentViewElements = DesignService.GetCurrentViewElements().ToList();
        for (int i = currentViewElements.Count - 1; i >= 0; i--)
        {
            if (currentViewElements[i].ContainsPoint(x, y))
            {
                clickedElement = currentViewElements[i];
                break;
            }
        }
        
        if (clickedElement != null)
        {
            DesignService.SelectElement(clickedElement);
            DesignService.ShouldShowPropertiesDialog = true;
            DesignService.NotifyStateChanged();
        }
    }
    
    private async Task OnResizeStart((SelectionHandles.ResizeHandle Handle, MouseEventArgs Args) args)
    {
        if (SelectedElement == null) return;
        
        var (x, y) = await GetSvgPoint(args.Args);
        _isResizing = true;
        _currentResizeHandle = args.Handle;
        _dragStartX = x;
        _dragStartY = y;
        _elementStartX = SelectedElement.X;
        _elementStartY = SelectedElement.Y;
        
        // Store initial dimensions based on element type
        switch (SelectedElement)
        {
            case KRectangle rect:
                _elementStartWidth = rect.Width;
                _elementStartHeight = rect.Height;
                break;
            case KCircle circle:
                _elementStartRadius = circle.Radius;
                break;
            case KImage image:
                _elementStartWidth = image.Width;
                _elementStartHeight = image.Height;
                break;
            case KLine line:
                _lineEndOffsetX = line.X2 - line.X;
                _lineEndOffsetY = line.Y2 - line.Y;
                break;
        }
    }
    
    private async Task OnMouseMove(MouseEventArgs e)
    {
        var (x, y) = await GetSvgPoint(e);
        
        // Handle drawing mode
        if (_isDrawing && _drawingElement != null)
        {
            UpdateDrawing(x, y);
            return;
        }
        
        if (SelectedElement == null) return;
        
        var dx = x - _dragStartX;
        var dy = y - _dragStartY;
        
        if (_isResizing)
        {
            ApplyResize(dx, dy);
            DesignService.NotifyStateChanged();
        }
        else if (_isDragging)
        {
            SelectedElement.X = _elementStartX + dx;
            SelectedElement.Y = _elementStartY + dy;
            
            // For lines, move the end point by applying the stored offset
            if (SelectedElement is KLine line)
            {
                line.X2 = SelectedElement.X + _lineEndOffsetX;
                line.Y2 = SelectedElement.Y + _lineEndOffsetY;
            }
            
            DesignService.NotifyStateChanged();
        }
    }
    
    private void UpdateDrawing(double x, double y)
    {
        switch (_drawingElement)
        {
            case KRectangle rect:
                // Calculate width and height, handling negative values
                var rectWidth = x - _dragStartX;
                var rectHeight = y - _dragStartY;
                
                if (rectWidth < 0)
                {
                    rect.X = x;
                    rect.Width = -rectWidth;
                }
                else
                {
                    rect.X = _dragStartX;
                    rect.Width = rectWidth;
                }
                
                if (rectHeight < 0)
                {
                    rect.Y = y;
                    rect.Height = -rectHeight;
                }
                else
                {
                    rect.Y = _dragStartY;
                    rect.Height = rectHeight;
                }
                break;
                
            case KCircle circle:
                // Radius is distance from start point to current point
                var dx = x - _dragStartX;
                var dy = y - _dragStartY;
                circle.Radius = Math.Sqrt(dx * dx + dy * dy);
                break;
                
            case KLine line:
                // End point follows the mouse
                line.X2 = x;
                line.Y2 = y;
                break;
        }
        
        DesignService.NotifyStateChanged();
    }
    
    private void ApplyResize(double dx, double dy)
    {
        switch (SelectedElement)
        {
            case KRectangle rect:
                ApplyRectangleResize(rect, dx, dy);
                break;
            case KCircle circle:
                ApplyCircleResize(circle, dx, dy);
                break;
            case KImage image:
                ApplyImageResize(image, dx, dy);
                break;
            case KLine line:
                ApplyLineResize(line, dx, dy);
                break;
            case KText text:
                ApplyTextResize(text, dx, dy);
                break;
        }
    }
    
    private void ApplyRectangleResize(KRectangle rect, double dx, double dy)
    {
        const double minSize = 10;
        
        switch (_currentResizeHandle)
        {
            case SelectionHandles.ResizeHandle.TopLeft:
                rect.X = _elementStartX + dx;
                rect.Y = _elementStartY + dy;
                rect.Width = Math.Max(minSize, _elementStartWidth - dx);
                rect.Height = Math.Max(minSize, _elementStartHeight - dy);
                break;
            case SelectionHandles.ResizeHandle.TopRight:
                rect.Y = _elementStartY + dy;
                rect.Width = Math.Max(minSize, _elementStartWidth + dx);
                rect.Height = Math.Max(minSize, _elementStartHeight - dy);
                break;
            case SelectionHandles.ResizeHandle.BottomLeft:
                rect.X = _elementStartX + dx;
                rect.Width = Math.Max(minSize, _elementStartWidth - dx);
                rect.Height = Math.Max(minSize, _elementStartHeight + dy);
                break;
            case SelectionHandles.ResizeHandle.BottomRight:
                rect.Width = Math.Max(minSize, _elementStartWidth + dx);
                rect.Height = Math.Max(minSize, _elementStartHeight + dy);
                break;
        }
    }
    
    private void ApplyCircleResize(KCircle circle, double dx, double dy)
    {
        const double minRadius = 5;
        var delta = Math.Max(Math.Abs(dx), Math.Abs(dy));
        
        switch (_currentResizeHandle)
        {
            case SelectionHandles.ResizeHandle.TopLeft:
                circle.Radius = Math.Max(minRadius, _elementStartRadius - delta * Math.Sign(dx + dy) / 2);
                break;
            case SelectionHandles.ResizeHandle.TopRight:
                circle.Radius = Math.Max(minRadius, _elementStartRadius + (dx - dy) / 2);
                break;
            case SelectionHandles.ResizeHandle.BottomLeft:
                circle.Radius = Math.Max(minRadius, _elementStartRadius + (-dx + dy) / 2);
                break;
            case SelectionHandles.ResizeHandle.BottomRight:
                circle.Radius = Math.Max(minRadius, _elementStartRadius + delta * Math.Sign(dx + dy) / 2);
                break;
        }
    }
    
    private void ApplyImageResize(KImage image, double dx, double dy)
    {
        const double minSize = 10;
        
        switch (_currentResizeHandle)
        {
            case SelectionHandles.ResizeHandle.TopLeft:
                image.X = _elementStartX + dx;
                image.Y = _elementStartY + dy;
                image.Width = Math.Max(minSize, _elementStartWidth - dx);
                image.Height = Math.Max(minSize, _elementStartHeight - dy);
                break;
            case SelectionHandles.ResizeHandle.TopRight:
                image.Y = _elementStartY + dy;
                image.Width = Math.Max(minSize, _elementStartWidth + dx);
                image.Height = Math.Max(minSize, _elementStartHeight - dy);
                break;
            case SelectionHandles.ResizeHandle.BottomLeft:
                image.X = _elementStartX + dx;
                image.Width = Math.Max(minSize, _elementStartWidth - dx);
                image.Height = Math.Max(minSize, _elementStartHeight + dy);
                break;
            case SelectionHandles.ResizeHandle.BottomRight:
                image.Width = Math.Max(minSize, _elementStartWidth + dx);
                image.Height = Math.Max(minSize, _elementStartHeight + dy);
                break;
        }
    }
    
    private void ApplyLineResize(KLine line, double dx, double dy)
    {
        switch (_currentResizeHandle)
        {
            case SelectionHandles.ResizeHandle.TopLeft:
            case SelectionHandles.ResizeHandle.BottomLeft:
                // Move start point
                line.X = _elementStartX + dx;
                line.Y = _elementStartY + dy;
                break;
            case SelectionHandles.ResizeHandle.TopRight:
            case SelectionHandles.ResizeHandle.BottomRight:
                // Move end point
                line.X2 = _elementStartX + _lineEndOffsetX + dx;
                line.Y2 = _elementStartY + _lineEndOffsetY + dy;
                break;
        }
    }
    
    private void ApplyTextResize(KText text, double dx, double dy)
    {
        const double minFontSize = 8;
        
        // For text, we adjust font size based on the resize
        switch (_currentResizeHandle)
        {
            case SelectionHandles.ResizeHandle.BottomRight:
            case SelectionHandles.ResizeHandle.TopRight:
                text.FontSize = Math.Max(minFontSize, text.FontSize + dy * 0.1);
                break;
            case SelectionHandles.ResizeHandle.BottomLeft:
            case SelectionHandles.ResizeHandle.TopLeft:
                text.FontSize = Math.Max(minFontSize, text.FontSize - dy * 0.1);
                break;
        }
    }
    
    private void OnMouseUp(MouseEventArgs e)
    {
        // Finalize drawing
        if (_isDrawing && _drawingElement != null)
        {
            // Check if the element is too small (accidental click)
            var isTooSmall = _drawingElement switch
            {
                KRectangle rect => rect.Width < 5 && rect.Height < 5,
                KCircle circle => circle.Radius < 5,
                KLine line => Math.Abs(line.X2 - line.X) < 5 && Math.Abs(line.Y2 - line.Y) < 5,
                _ => false
            };
            
            if (isTooSmall)
            {
                // Remove the element if too small
                Document.Elements.Remove(_drawingElement);
            }
            else
            {
                // Select the newly created element
                DesignService.SelectElement(_drawingElement);
            }
            
            _isDrawing = false;
            _drawingElement = null;
            DesignService.CurrentTool = DrawingTool.Select;
            Document.ModifiedAt = DateTime.UtcNow;
            DesignService.NotifyStateChanged();
            return;
        }
        
        if (_isDragging || _isResizing)
        {
            _isDragging = false;
            _isResizing = false;
            Document.ModifiedAt = DateTime.UtcNow;
        }
    }
    
    private void OnWheel(WheelEventArgs e)
    {
        if (e.CtrlKey)
        {
            // Zoom
            var delta = e.DeltaY < 0 ? 1.1 : 0.9;
            _zoom = Math.Clamp(_zoom * delta, 0.1, 5.0);
        }
        else
        {
            // Pan
            _panX += e.DeltaX * 0.5 / _zoom;
            _panY += e.DeltaY * 0.5 / _zoom;
            _panX = Math.Max(0, _panX);
            _panY = Math.Max(0, _panY);
        }
    }
}
