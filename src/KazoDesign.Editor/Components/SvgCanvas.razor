@using KazoDesign.Editor.Models
@using KazoDesign.Editor.Services
@inject DesignService DesignService
@inject IJSRuntime JS

<div class="canvas-container" @ref="_containerRef">
    <svg @ref="_svgRef"
         class="design-canvas"
         viewBox="@ViewBox"
         @onmousedown="OnMouseDown"
         @onmousemove="OnMouseMove"
         @onmouseup="OnMouseUp"
         @onmouseleave="OnMouseUp"
         @onwheel="OnWheel">
        
        <!-- Background -->
        <rect x="0" y="0" 
              width="@Document.CanvasWidth.ToString(System.Globalization.CultureInfo.InvariantCulture)" 
              height="@Document.CanvasHeight.ToString(System.Globalization.CultureInfo.InvariantCulture)" 
              fill="@Document.BackgroundColor" />
        
        <!-- Grid Pattern -->
        <defs>
            <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
                <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#333" stroke-width="0.5"/>
            </pattern>
        </defs>
        <rect x="0" y="0" 
              width="@Document.CanvasWidth.ToString(System.Globalization.CultureInfo.InvariantCulture)" 
              height="@Document.CanvasHeight.ToString(System.Globalization.CultureInfo.InvariantCulture)" 
              fill="url(#grid)" />
        
        <!-- Render all elements -->
        @foreach (var element in Document.Elements)
        {
            @switch (element)
            {
                case KRectangle rect:
                    <KRectangleRenderer Shape="@rect" />
                    break;
                case KCircle circle:
                    <KCircleRenderer Shape="@circle" />
                    break;
                case KLine line:
                    <KLineRenderer Shape="@line" />
                    break;
                case KText text:
                    <KTextRenderer Shape="@text" />
                    break;
                case KImage image:
                    <KImageRenderer Shape="@image" />
                    break;
            }
        }
        
        <!-- Selection handles for selected element -->
        @if (SelectedElement != null)
        {
            <SelectionHandles Element="@SelectedElement" OnResizeStart="OnResizeStart" />
        }
    </svg>
</div>

@code {
    private ElementReference _svgRef;
    private ElementReference _containerRef;
    
    private bool _isDragging;
    private bool _isResizing;
    private SelectionHandles.ResizeHandle _currentResizeHandle;
    private double _dragStartX;
    private double _dragStartY;
    private double _elementStartX;
    private double _elementStartY;
    private double _elementStartWidth;
    private double _elementStartHeight;
    private double _elementStartRadius;
    private double _lineEndOffsetX;  // Offset from line start to end point
    private double _lineEndOffsetY;
    
    private double _zoom = 1.0;
    private double _panX = 0;
    private double _panY = 0;
    
    public DesignDocument Document => DesignService.Document;
    public DesignElement? SelectedElement => DesignService.SelectedElement;
    
    private string ViewBox => $"{_panX} {_panY} {Document.CanvasWidth / _zoom} {Document.CanvasHeight / _zoom}";
    
    protected override void OnInitialized()
    {
        DesignService.OnChange += StateHasChanged;
    }
    
    public void Dispose()
    {
        DesignService.OnChange -= StateHasChanged;
    }
    
    private async Task<(double x, double y)> GetSvgPoint(MouseEventArgs e)
    {
        try
        {
            var result = await JS.InvokeAsync<double[]>("kazoDesign.getSvgPoint", _svgRef, e.ClientX, e.ClientY);
            return (result[0], result[1]);
        }
        catch
        {
            return (e.ClientX, e.ClientY);
        }
    }
    
    private async Task OnMouseDown(MouseEventArgs e)
    {
        var (x, y) = await GetSvgPoint(e);
        
        // Find element under cursor (reverse order for z-index)
        DesignElement? clickedElement = null;
        for (int i = Document.Elements.Count - 1; i >= 0; i--)
        {
            if (Document.Elements[i].ContainsPoint(x, y))
            {
                clickedElement = Document.Elements[i];
                break;
            }
        }
        
        DesignService.SelectElement(clickedElement);
        
        if (clickedElement != null)
        {
            _isDragging = true;
            _dragStartX = x;
            _dragStartY = y;
            _elementStartX = clickedElement.X;
            _elementStartY = clickedElement.Y;
            
            // Store line end offset for proper line movement
            if (clickedElement is KLine line)
            {
                _lineEndOffsetX = line.X2 - line.X;
                _lineEndOffsetY = line.Y2 - line.Y;
            }
        }
    }
    
    private async Task OnResizeStart((SelectionHandles.ResizeHandle Handle, MouseEventArgs Args) args)
    {
        if (SelectedElement == null) return;
        
        var (x, y) = await GetSvgPoint(args.Args);
        _isResizing = true;
        _currentResizeHandle = args.Handle;
        _dragStartX = x;
        _dragStartY = y;
        _elementStartX = SelectedElement.X;
        _elementStartY = SelectedElement.Y;
        
        // Store initial dimensions based on element type
        switch (SelectedElement)
        {
            case KRectangle rect:
                _elementStartWidth = rect.Width;
                _elementStartHeight = rect.Height;
                break;
            case KCircle circle:
                _elementStartRadius = circle.Radius;
                break;
            case KImage image:
                _elementStartWidth = image.Width;
                _elementStartHeight = image.Height;
                break;
            case KLine line:
                _lineEndOffsetX = line.X2 - line.X;
                _lineEndOffsetY = line.Y2 - line.Y;
                break;
        }
    }
    
    private async Task OnMouseMove(MouseEventArgs e)
    {
        if (SelectedElement == null) return;
        
        var (x, y) = await GetSvgPoint(e);
        var dx = x - _dragStartX;
        var dy = y - _dragStartY;
        
        if (_isResizing)
        {
            ApplyResize(dx, dy);
            DesignService.NotifyStateChanged();
        }
        else if (_isDragging)
        {
            SelectedElement.X = _elementStartX + dx;
            SelectedElement.Y = _elementStartY + dy;
            
            // For lines, move the end point by applying the stored offset
            if (SelectedElement is KLine line)
            {
                line.X2 = SelectedElement.X + _lineEndOffsetX;
                line.Y2 = SelectedElement.Y + _lineEndOffsetY;
            }
            
            DesignService.NotifyStateChanged();
        }
    }
    
    private void ApplyResize(double dx, double dy)
    {
        switch (SelectedElement)
        {
            case KRectangle rect:
                ApplyRectangleResize(rect, dx, dy);
                break;
            case KCircle circle:
                ApplyCircleResize(circle, dx, dy);
                break;
            case KImage image:
                ApplyImageResize(image, dx, dy);
                break;
            case KLine line:
                ApplyLineResize(line, dx, dy);
                break;
            case KText text:
                ApplyTextResize(text, dx, dy);
                break;
        }
    }
    
    private void ApplyRectangleResize(KRectangle rect, double dx, double dy)
    {
        const double minSize = 10;
        
        switch (_currentResizeHandle)
        {
            case SelectionHandles.ResizeHandle.TopLeft:
                rect.X = _elementStartX + dx;
                rect.Y = _elementStartY + dy;
                rect.Width = Math.Max(minSize, _elementStartWidth - dx);
                rect.Height = Math.Max(minSize, _elementStartHeight - dy);
                break;
            case SelectionHandles.ResizeHandle.TopRight:
                rect.Y = _elementStartY + dy;
                rect.Width = Math.Max(minSize, _elementStartWidth + dx);
                rect.Height = Math.Max(minSize, _elementStartHeight - dy);
                break;
            case SelectionHandles.ResizeHandle.BottomLeft:
                rect.X = _elementStartX + dx;
                rect.Width = Math.Max(minSize, _elementStartWidth - dx);
                rect.Height = Math.Max(minSize, _elementStartHeight + dy);
                break;
            case SelectionHandles.ResizeHandle.BottomRight:
                rect.Width = Math.Max(minSize, _elementStartWidth + dx);
                rect.Height = Math.Max(minSize, _elementStartHeight + dy);
                break;
        }
    }
    
    private void ApplyCircleResize(KCircle circle, double dx, double dy)
    {
        const double minRadius = 5;
        var delta = Math.Max(Math.Abs(dx), Math.Abs(dy));
        
        switch (_currentResizeHandle)
        {
            case SelectionHandles.ResizeHandle.TopLeft:
                circle.Radius = Math.Max(minRadius, _elementStartRadius - delta * Math.Sign(dx + dy) / 2);
                break;
            case SelectionHandles.ResizeHandle.TopRight:
                circle.Radius = Math.Max(minRadius, _elementStartRadius + (dx - dy) / 2);
                break;
            case SelectionHandles.ResizeHandle.BottomLeft:
                circle.Radius = Math.Max(minRadius, _elementStartRadius + (-dx + dy) / 2);
                break;
            case SelectionHandles.ResizeHandle.BottomRight:
                circle.Radius = Math.Max(minRadius, _elementStartRadius + delta * Math.Sign(dx + dy) / 2);
                break;
        }
    }
    
    private void ApplyImageResize(KImage image, double dx, double dy)
    {
        const double minSize = 10;
        
        switch (_currentResizeHandle)
        {
            case SelectionHandles.ResizeHandle.TopLeft:
                image.X = _elementStartX + dx;
                image.Y = _elementStartY + dy;
                image.Width = Math.Max(minSize, _elementStartWidth - dx);
                image.Height = Math.Max(minSize, _elementStartHeight - dy);
                break;
            case SelectionHandles.ResizeHandle.TopRight:
                image.Y = _elementStartY + dy;
                image.Width = Math.Max(minSize, _elementStartWidth + dx);
                image.Height = Math.Max(minSize, _elementStartHeight - dy);
                break;
            case SelectionHandles.ResizeHandle.BottomLeft:
                image.X = _elementStartX + dx;
                image.Width = Math.Max(minSize, _elementStartWidth - dx);
                image.Height = Math.Max(minSize, _elementStartHeight + dy);
                break;
            case SelectionHandles.ResizeHandle.BottomRight:
                image.Width = Math.Max(minSize, _elementStartWidth + dx);
                image.Height = Math.Max(minSize, _elementStartHeight + dy);
                break;
        }
    }
    
    private void ApplyLineResize(KLine line, double dx, double dy)
    {
        switch (_currentResizeHandle)
        {
            case SelectionHandles.ResizeHandle.TopLeft:
            case SelectionHandles.ResizeHandle.BottomLeft:
                // Move start point
                line.X = _elementStartX + dx;
                line.Y = _elementStartY + dy;
                break;
            case SelectionHandles.ResizeHandle.TopRight:
            case SelectionHandles.ResizeHandle.BottomRight:
                // Move end point
                line.X2 = _elementStartX + _lineEndOffsetX + dx;
                line.Y2 = _elementStartY + _lineEndOffsetY + dy;
                break;
        }
    }
    
    private void ApplyTextResize(KText text, double dx, double dy)
    {
        const double minFontSize = 8;
        
        // For text, we adjust font size based on the resize
        switch (_currentResizeHandle)
        {
            case SelectionHandles.ResizeHandle.BottomRight:
            case SelectionHandles.ResizeHandle.TopRight:
                text.FontSize = Math.Max(minFontSize, text.FontSize + dy * 0.1);
                break;
            case SelectionHandles.ResizeHandle.BottomLeft:
            case SelectionHandles.ResizeHandle.TopLeft:
                text.FontSize = Math.Max(minFontSize, text.FontSize - dy * 0.1);
                break;
        }
    }
    
    private void OnMouseUp(MouseEventArgs e)
    {
        if (_isDragging || _isResizing)
        {
            _isDragging = false;
            _isResizing = false;
            Document.ModifiedAt = DateTime.UtcNow;
        }
    }
    
    private void OnWheel(WheelEventArgs e)
    {
        if (e.CtrlKey)
        {
            // Zoom
            var delta = e.DeltaY < 0 ? 1.1 : 0.9;
            _zoom = Math.Clamp(_zoom * delta, 0.1, 5.0);
        }
        else
        {
            // Pan
            _panX += e.DeltaX * 0.5 / _zoom;
            _panY += e.DeltaY * 0.5 / _zoom;
            _panX = Math.Max(0, _panX);
            _panY = Math.Max(0, _panY);
        }
    }
}
